import { MDGenerator } from '../../src/core/generator.js';

import fs from 'fs-extra';
import path from 'path';
import { EventEmitter } from 'events';
import { jest } from '@jest/globals';

describe('MDGenerator', () => {
  let generator;
  let mockParser;
  
  const testConfig = {
    paths: {
      settings: '/test/path/settings.json',
      markdown: '/test/path/output.md'
    }
  };
  
  beforeEach(() => {
    // Mock the parser
    mockParser = {
      getToolDescription: jest.fn().mockImplementation((toolName) => {
        const descriptions = {
          'tool1': 'Tool 1 description',
          'tool2': 'Tool 2 description',
          'playwright_navigate': 'Navigates to a specified URL in a browser instance.',
          'get_current_time': 'Retrieves the current date and time.'
        };
        return descriptions[toolName] || 'No description available.';
      })
    };
    
    // Create generator instance
    generator = new MDGenerator(testConfig, mockParser);
    
    // Add event listeners to prevent "possible memory leak" warnings
    generator.on('debug', () => {});
    generator.on('error', () => {});
    
    // Mock fs methods directly in beforeEach
    fs.readFile = jest.fn().mockResolvedValue(JSON.stringify({
      mcpServers: {
        'github.com/test/server1': {
          autoApprove: ['tool1']
        },
        'github.com/test/server2': {
          autoApprove: ['tool2']
        }
      }
    }));
    fs.ensureDir = jest.fn().mockResolvedValue();
    fs.writeFile = jest.fn().mockResolvedValue();
    fs.pathExists = jest.fn().mockResolvedValue(true);
  });
  
  describe('Constructor', () => {
    it('should extend EventEmitter', () => {
      expect(generator).toBeInstanceOf(EventEmitter);
    });
    
    it('should initialize with config and parser', () => {
      expect(generator.config).toBe(testConfig);
      expect(generator.parser).toBe(mockParser);
      expect(generator.HEADER_MARKER).toBe('# MCP Servers and Tools');
      expect(generator.FOOTER_MARKER).toBe('This documentation is automatically generated by MCP Config Watcher.');
    });
  });
  
  describe('generateMarkdown()', () => {
    it('should generate markdown documentation', async () => {
      // Setup
      const data = {
        servers: {
          'github.com/test/server1': {
            tools: ['tool1']
          }
        }
      };
      
      generator.safeUpdateMarkdown = jest.fn().mockResolvedValue();
      
      // Act
      const result = await generator.generateMarkdown(data);
      
      // Assert
      expect(result).toBe(true);
      expect(fs.ensureDir).toHaveBeenCalled();
      expect(fs.readFile).toHaveBeenCalledWith(testConfig.paths.settings, 'utf8');
      expect(generator.safeUpdateMarkdown).toHaveBeenCalled();
    });
    
    it('should throw error when generation fails', async () => {
      // Setup
      const data = {
        servers: {}
      };
      
      const error = new Error('Test error');
      fs.readFile.mockRejectedValue(error);
      
      // Act & Assert
      await expect(generator.generateMarkdown(data)).rejects.toThrow('Failed to generate markdown');
    });
  });
  
  describe('safeUpdateMarkdown()', () => {
    it('should create new file when file does not exist', async () => {
      // Setup
      fs.pathExists.mockResolvedValue(false); // File doesn't exist
      const data = { servers: {} };
      const settings = { mcpServers: {} };
      
      generator.buildMarkdown = jest.fn().mockReturnValue('# Test Markdown');
      
      // Act
      await generator.safeUpdateMarkdown('/test/output.md', data, settings);
      
      // Assert
      expect(generator.buildMarkdown).toHaveBeenCalled();
      expect(fs.writeFile).toHaveBeenCalled();
    });
    
    it('should update existing file', async () => {
      // Setup
      const existingContent = '# MCP Servers and Tools\n\nExisting content\n\nThis documentation is automatically generated by MCP Config Watcher.';
      fs.readFile.mockResolvedValue(existingContent);
      
      const data = { servers: {} };
      const settings = { mcpServers: {} };
      
      generator.parseExistingContent = jest.fn().mockReturnValue({
        header: '# MCP Servers and Tools\n\n',
        servers: {},
        footer: '\nThis documentation is automatically generated by MCP Config Watcher.\n'
      });
      
      generator.generateServerSections = jest.fn().mockReturnValue({});
      generator.mergeContent = jest.fn().mockReturnValue('# New Content');
      
      // Act
      await generator.safeUpdateMarkdown('/test/output.md', data, settings);
      
      // Assert
      expect(generator.parseExistingContent).toHaveBeenCalledWith(existingContent);
      expect(generator.generateServerSections).toHaveBeenCalled();
      expect(generator.mergeContent).toHaveBeenCalled();
      expect(fs.writeFile).toHaveBeenCalledWith('/test/output.md', '# New Content', 'utf8');
    });
    
    it('should create backup files for main documentation file', async () => {
      // Setup
      const filePath = '/test/path/mcp_servers_and_tools.md';
      fs.readFile.mockResolvedValue('# Existing Content');
      
      generator.parseExistingContent = jest.fn().mockReturnValue({
        header: '# MCP Servers and Tools\n\n',
        servers: {},
        footer: '\nThis documentation is automatically generated by MCP Config Watcher.\n'
      });
      
      generator.generateServerSections = jest.fn().mockReturnValue({});
      generator.mergeContent = jest.fn().mockReturnValue('# New Content');
      generator.buildMarkdown = jest.fn().mockReturnValue('# Direct Content');
      
      // Act
      await generator.safeUpdateMarkdown(filePath, {}, {});
      
      // Assert
      expect(fs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('mcp_servers_and_tools_debug.md'),
        '# Existing Content',
        'utf8'
      );
      
      expect(fs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('mcp_servers_and_tools_direct.md'),
        '# Direct Content',
        'utf8'
      );
    });
    
    it('should throw error when update fails', async () => {
      // Setup
      fs.readFile.mockRejectedValue(new Error('Test error'));
      
      // Act & Assert
      await expect(generator.safeUpdateMarkdown('/test/output.md', {}, {}))
        .rejects
        .toThrow('Failed to safely update markdown');
    });
  });
  
  describe('parseExistingContent()', () => {
    it('should parse header, server sections, and footer', () => {
      // Setup
      const content = `# MCP Servers and Tools

This document provides an overview of all MCP servers.

## Server 1

- **tool1**: Tool 1 description.

## Server 2

- **tool2**: Tool 2 description.

This documentation is automatically generated by MCP Config Watcher.
Last updated: 2023-01-01`;

      // Act
      const result = generator.parseExistingContent(content);
      
      // Assert
      expect(result.header).toContain('# MCP Servers and Tools');
      expect(result.header).toContain('This document provides an overview');
      
      expect(Object.keys(result.servers)).toHaveLength(2);
      expect(result.servers['Server 1']).toContain('- **tool1**');
      expect(result.servers['Server 2']).toContain('- **tool2**');
      
      expect(result.footer).toContain('This documentation is automatically generated');
      expect(result.footer).toContain('Last updated');
    });
    
    it('should handle content without header marker', () => {
      // Setup
      const content = 'Some content without proper header';
      
      // Act
      const result = generator.parseExistingContent(content);
      
      // Assert
      expect(result.header).toContain('# MCP Servers and Tools');
      expect(result.header).toContain('This document provides an overview');
    });
    
    it('should handle content without footer marker', () => {
      // Setup
      const content = '# MCP Servers and Tools\n\nContent without footer';
      
      // Act
      const result = generator.parseExistingContent(content);
      
      // Assert
      expect(result.footer).toContain('This documentation is automatically generated');
      expect(result.footer).toContain('Last updated');
    });
  });
  
  describe('generateServerSections()', () => {
    it('should generate sections for all servers', () => {
      // Setup
      const data = {
        servers: {
          'github.com/executeautomation/mcp-playwright': {
            tools: ['playwright_navigate']
          },
          'github.com/modelcontextprotocol/servers/tree/main/src/time': {
            tools: ['get_current_time']
          }
        }
      };
      
      const settings = {
        mcpServers: {
          'github.com/executeautomation/mcp-playwright': {
            autoApprove: ['playwright_navigate']
          }
        }
      };
      
      const debugSpy = jest.spyOn(generator, 'emit');
      
      // Act
      const result = generator.generateServerSections(data, settings);
      
      // Assert
      expect(Object.keys(result)).toHaveLength(2);
      
      // Check Playwright server
      expect(result['github.com/executeautomation/mcp-playwright']).toContain('- **playwright_navigate** ðŸ”“ (Auto-Approved)');
      
      // Check Time server
      expect(result['github.com/modelcontextprotocol/servers/tree/main/src/time']).toContain('- **get_current_time**');
      
      // Check debug events
      expect(debugSpy).toHaveBeenCalledWith('debug', expect.any(String));
    });
    
    it('should generate default tools when no tools are available', () => {
      // Setup
      const data = {
        servers: {
          'github.com/test/empty-server': {
            tools: []
          }
        }
      };
      
      const settings = {
        mcpServers: {}
      };
      
      // Act
      const result = generator.generateServerSections(data, settings);
      
      // Assert
      expect(result['github.com/test/empty-server']).toContain('- **empty_server_tool**');
    });
  });
  
  describe('mergeContent()', () => {
    it('should merge sections and update footer', () => {
      // Setup
      const existingSections = {
        header: '# MCP Servers and Tools\n\nHeader content\n\n',
        servers: {
          'Server 1': '- **tool1**: Description 1\n'
        },
        footer: '\nOld footer'
      };
      
      const newServerSections = {
        'Server 1': '- **tool1**: Updated description\n',
        'Server 2': '- **tool2**: Description 2\n'
      };
      
      // Act
      const result = generator.mergeContent(existingSections, newServerSections);
      
      // Assert
      expect(result).toContain('# MCP Servers and Tools');
      expect(result).toContain('Header content');
      expect(result).toContain('## Server 1');
      expect(result).toContain('## Server 2');
      expect(result).toContain('- **tool1**: Updated description');
      expect(result).toContain('- **tool2**: Description 2');
      expect(result).toContain('This documentation is automatically generated');
      expect(result).toContain('Last updated');
      
      // Old footer should be replaced
      expect(result).not.toContain('Old footer');
    });
  });
  
  describe('buildMarkdown()', () => {
    it('should build complete markdown content', () => {
      // Setup
      const data = {
        servers: {
          'Server 1': {
            tools: ['tool1']
          }
        }
      };
      
      const settings = {};
      
      generator.generateServerSections = jest.fn().mockReturnValue({
        'Server 1': '- **tool1**: Tool 1 description\n'
      });
      
      // Act
      const result = generator.buildMarkdown(data, settings);
      
      // Assert
      expect(result).toContain('# MCP Servers and Tools');
      expect(result).toContain('## Server 1');
      expect(result).toContain('This documentation is automatically generated');
      expect(result).toContain('Last updated');
      expect(generator.generateServerSections).toHaveBeenCalledWith(data, settings);
    });
  });
});
