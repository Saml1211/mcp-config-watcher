import fs from 'fs-extra';
import path from 'path';
import { EventEmitter } from 'events';

/**
 * Markdown generator class
 * Generates markdown documentation for MCP servers and tools
 */
export class MDGenerator extends EventEmitter {
  /**
   * Create a new generator instance
   * @param {Object} config - Configuration object
   * @param {MCPSettingsParser} parser - Parser instance
   */
  constructor(config, parser) {
    super();
    this.config = config;
    this.parser = parser;
    this.HEADER_MARKER = '# MCP Servers and Tools';
    this.FOOTER_MARKER = 'This documentation is automatically generated by MCP Config Watcher.';
  }

  /**
   * Generate markdown documentation
   * @param {Object} data - Parsed MCP settings data
   * @returns {Promise<boolean>} Success status
   */
  async generateMarkdown(data) {
    try {
      const markdownPath = this.config.paths.markdown;
      const settingsPath = this.config.paths.settings;
      
      // Create directory if it doesn't exist
      const dir = path.dirname(markdownPath);
      await fs.ensureDir(dir);
      
      // Read actual settings file to get auto-approve information
      const rawSettings = await fs.readFile(settingsPath, 'utf8');
      const settings = JSON.parse(rawSettings);
      
      // Use safe writing mechanism
      await this.safeUpdateMarkdown(markdownPath, data, settings);
      return true;
    } catch (error) {
      throw new Error(`Failed to generate markdown: ${error.message}`);
    }
  }

  /**
   * Safely update the markdown file preserving user content
   * @param {string} filePath - Path to markdown file
   * @param {Object} data - Parsed MCP settings data
   * @param {Object} settings - Raw MCP settings from the settings file
   * @returns {Promise<void>}
   * @private
   */
  async safeUpdateMarkdown(filePath, data, settings) {
    try {
      let existingContent = '';
      let hasExistingFile = false;
      
      // Check if file exists
      try {
        existingContent = await fs.readFile(filePath, 'utf8');
        hasExistingFile = true;
      } catch (error) {
        // File doesn't exist, will create new one
        hasExistingFile = false;
      }
      
      // Check if this is the mcp_servers_and_tools.md file
      const isMainDocFile = path.basename(filePath) === 'mcp_servers_and_tools.md';
      
      // If file doesn't exist, just create a new one with all content
      if (!hasExistingFile) {
        const markdown = this.buildMarkdown(data, settings);
        await fs.writeFile(filePath, markdown, 'utf8');
        return;
      }
      
      // For the main documentation file, check if we have a backup/direct version
      if (isMainDocFile) {
        const directFilePath = path.join(path.dirname(filePath), 'mcp_servers_and_tools_direct.md');
        const debugFilePath = path.join(path.dirname(filePath), 'mcp_servers_and_tools_debug.md');
        
        try {
          // Create a debug copy for troubleshooting
          await fs.writeFile(debugFilePath, existingContent, 'utf8');
          
          // Create or update the direct version (without preserving user content)
          const directMarkdown = this.buildMarkdown(data, settings);
          await fs.writeFile(directFilePath, directMarkdown, 'utf8');
          
          // If the main file was accidentally overwritten, restore from direct version
          if (!existingContent.includes(this.HEADER_MARKER)) {
            console.log('[WARNING] Main documentation file may have been corrupted, restoring from direct version');
            existingContent = directMarkdown;
          }
        } catch (error) {
          console.error(`Failed to create backup files: ${error.message}`);
        }
      }
      
      // Parse existing content to identify server sections
      const sections = this.parseExistingContent(existingContent);
      
      // Generate new server sections
      const newServerSections = this.generateServerSections(data, settings);
      
      // Merge content
      const updatedContent = this.mergeContent(sections, newServerSections);
      
      // Write updated content
      await fs.writeFile(filePath, updatedContent, 'utf8');
    } catch (error) {
      throw new Error(`Failed to safely update markdown: ${error.message}`);
    }
  }

  /**
   * Parse existing markdown content into sections
   * @param {string} content - Existing markdown content
   * @returns {Object} Parsed sections
   * @private
   */
  parseExistingContent(content) {
    const sections = {
      header: '',
      servers: {},
      footer: '',
      preservedContent: ''
    };
    
    // Split content by lines
    const lines = content.split('\n');
    
    let currentSection = 'header';
    let currentServer = null;
    let headerEndIndex = -1;
    let footerStartIndex = -1;
    
    // Find header end index
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].startsWith(this.HEADER_MARKER)) {
        // Continue to include intro text in header
        for (let j = i + 1; j < lines.length; j++) {
          if (lines[j].startsWith('## ')) {
            headerEndIndex = j - 1;
            break;
          }
        }
        break;
      }
    }
    
    // Find footer start index
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].startsWith(this.FOOTER_MARKER) || lines[i].includes(this.FOOTER_MARKER)) {
        footerStartIndex = i;
        break;
      }
    }
    
    // Extract header content
    if (headerEndIndex > 0) {
      sections.header = lines.slice(0, headerEndIndex + 1).join('\n') + '\n\n';
    } else {
      // Default header if not found
      sections.header = this.HEADER_MARKER + '\n\n' + 
        'This document provides an overview of all configured MCP servers and their available tools.\n\n';
    }
    
    // Extract server sections
    let i = headerEndIndex + 1;
    while (i < lines.length) {
      const line = lines[i];
      
      if (line.startsWith('## ')) {
        // New server section
        currentServer = line.substring(3).trim();
        sections.servers[currentServer] = [];
        i++;
        continue;
      }
      
      if (line.startsWith(this.FOOTER_MARKER) || i >= footerStartIndex) {
        // Reached footer
        break;
      }
      
      if (currentServer) {
        // Add line to current server
        sections.servers[currentServer].push(line);
      }
      
      i++;
    }
    
    // Convert server lines arrays to strings
    for (const server in sections.servers) {
      sections.servers[server] = sections.servers[server].join('\n');
    }
    
    // Extract footer content
    if (footerStartIndex > 0) {
      sections.footer = '\n' + lines.slice(footerStartIndex).join('\n');
    } else {
      // Default footer if not found
      sections.footer = '\n' + this.FOOTER_MARKER + '\n' +
        `Last updated: ${new Date().toLocaleString()}\n`;
    }
    
    return sections;
  }

  /**
   * Generate server sections for the markdown file
   * @param {Object} data - Parsed MCP settings data
   * @param {Object} settings - Raw MCP settings from the settings file
   * @returns {Object} Server sections
   * @private
   */
  generateServerSections(data, settings) {
    const { servers } = data;
    const serverSections = {};
    
    // Create a map of server IDs to their auto-approved tools directly from settings
    const autoApproveMap = {};
    if (settings && settings.mcpServers) {
      for (const [serverId, serverConfig] of Object.entries(settings.mcpServers)) {
        if (serverConfig.autoApprove && Array.isArray(serverConfig.autoApprove)) {
          autoApproveMap[serverId] = serverConfig.autoApprove;
        }
      }
    }
    
    for (const [serverId, server] of Object.entries(servers)) {
      let content = '';
      
      // Get tools for this server
      let serverTools = server.tools || [];
      
      // Get auto-approved tools directly from settings
      const autoApproveTools = autoApproveMap[serverId] || [];
      
      // Emit info for logging if needed
      this.emit('debug', `Server: ${serverId}`);
      this.emit('debug', `Tools: ${serverTools.join(', ')}`);
      this.emit('debug', `Auto-approve: ${autoApproveTools.join(', ')}`);
      
      // Combine tools from all sources, ensuring we have at least the auto-approved tools
      for (const tool of autoApproveTools) {
        if (!serverTools.includes(tool)) {
          serverTools.push(tool);
        }
      }
      
      // If we still don't have any tools, generate a reasonable default based on server name
      if (serverTools.length === 0) {
        // Extract server name from ID for a reasonable default
        const serverName = serverId.split('/').pop().replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
        
        // Generate a list of likely tools based on the server name
        const likelyTools = [];
        
        // Common prefixes for tools
        const commonPrefixes = ['get_', 'create_', 'update_', 'delete_', 'search_', 'list_'];
        
        // Add a generic tool based on the server name
        likelyTools.push(`${serverName}_tool`);
        
        // Add some common operations with the server name
        for (const prefix of commonPrefixes) {
          likelyTools.push(`${prefix}${serverName}`);
        }
        
        // Use just the first tool to avoid cluttering the documentation
        serverTools = [likelyTools[0]];
        
        // Add a note about predicted tools
        content += `> Note: Tools for this server are predicted based on naming conventions. Actual tools may differ.\n\n`;
      }
      
      // Sort tools alphabetically
      serverTools.sort();
      
      // Generate tool entries
      for (const toolName of serverTools) {
        const description = this.parser.getToolDescription(toolName);
        const isAutoApproved = autoApproveTools.includes(toolName);
        
        if (isAutoApproved) {
          // Highlight auto-approved tools with unlock icon and label
          content += `- **${toolName}** 🔓 (Auto-Approved): ${description}\n`;
        } else {
          content += `- **${toolName}**: ${description}\n`;
        }
      }
      
      // Add server configuration information if available
      if (settings && settings.mcpServers && settings.mcpServers[serverId]) {
        const serverConfig = settings.mcpServers[serverId];
        
        // Add a separator
        content += `\n### Server Configuration\n\n`;
        
        // Add command and args
        content += `- **Command**: \`${serverConfig.command}\`\n`;
        if (serverConfig.args && serverConfig.args.length > 0) {
          content += `- **Arguments**: \`${serverConfig.args.join(' ')}\`\n`;
        }
        
        // Add environment variables (without sensitive values)
        if (serverConfig.env && Object.keys(serverConfig.env).length > 0) {
          content += `- **Environment Variables**: `;
          const envVars = Object.keys(serverConfig.env).map(key => {
            // Mask potential API keys and tokens for security
            if (key.toLowerCase().includes('key') || 
                key.toLowerCase().includes('token') || 
                key.toLowerCase().includes('secret') || 
                key.toLowerCase().includes('password')) {
              return `${key}=********`;
            }
            return `${key}=${serverConfig.env[key]}`;
          });
          content += `\`${envVars.join(', ')}\`\n`;
        }
      }
      
      serverSections[serverId] = content;
    }
    
    return serverSections;
  }

  /**
   * Merge existing content with new server sections
   * @param {Object} existingSections - Existing content sections
   * @param {Object} newServerSections - New server sections
   * @returns {string} Merged content
   * @private
   */
  mergeContent(existingSections, newServerSections) {
    let content = existingSections.header;
    
    // Add all servers from new sections
    for (const [serverId, section] of Object.entries(newServerSections)) {
      content += `## ${serverId}\n\n${section}\n`;
    }
    
    // Update footer date
    const updatedFooter = this.FOOTER_MARKER + '\n' +
      `Last updated: ${new Date().toLocaleString()}\n`;
    
    content += updatedFooter;
    
    return content;
  }

  /**
   * Build markdown content (used for new files)
   * @param {Object} data - Parsed MCP settings data
   * @param {Object} settings - Raw MCP settings from the settings file
   * @returns {string} Markdown content
   * @private
   */
  buildMarkdown(data, settings) {
    let content = this.HEADER_MARKER + '\n\n';
    content += 'This document provides an overview of all configured MCP servers and their available tools.\n\n';
    
    // Generate server sections
    const serverSections = this.generateServerSections(data, settings);
    
    // Add all server sections
    for (const [serverId, section] of Object.entries(serverSections)) {
      content += `## ${serverId}\n\n${section}\n`;
    }
    
    // Add footer
    content += this.FOOTER_MARKER + '\n';
    content += `Last updated: ${new Date().toLocaleString()}\n`;
    
    return content;
  }
}

export default MDGenerator;
